<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Taskbar Snap Iframes</title>
<style>
  body { margin:0; font-family:sans-serif; background:#f0f0f0; }
  #addUnit { position: fixed; top: 10px; left:10px; padding:8px 12px; font-size:16px; }
  #taskbar { position: fixed; bottom:0; left:0; right:0; height:13cm; background:#333; display:flex; align-items:flex-start; padding:5px; box-sizing:border-box; user-select:none; }
  .unit-container { position: relative; width:13cm; height:13cm; margin:0 5px; display:flex; flex-direction:column; background:#222; border:1px solid #555; flex-shrink:0; transition: left 0.2s; }
  .drag-handle { height:20px; background:#555; cursor:grab; color:white; font-size:12px; display:flex; align-items:center; justify-content:center; user-select:none; }
  .unit-frame { flex:1; border:none; width:100%; height:100%; }
</style>
</head>
<body>

<button id="addUnit">Add Unit</button>
<div id="taskbar"></div>

<script>
const taskbar = document.getElementById('taskbar');
const addBtn = document.getElementById('addUnit');

const SLOT_WIDTH = 13 * 37.7952755906 + 10; // 13cm + margin in pixels
let slots = []; // Array of slot positions (logical order)

function createUnit() {
  const container = document.createElement('div');
  container.className = 'unit-container';

  const handle = document.createElement('div');
  handle.className = 'drag-handle';
  handle.textContent = 'Drag';

  const iframe = document.createElement('iframe');
  iframe.src = 'unit.html';
  iframe.className = 'unit-frame';

  container.appendChild(handle);
  container.appendChild(iframe);
  taskbar.appendChild(container);

  // Assign initial slot
  slots.push(container);
  updatePositions();

  let isDragging = false;
  let startX = 0;
  let startLeft = 0;
  let originalIndex = slots.indexOf(container);

  handle.addEventListener('pointerdown', (e) => {
    isDragging = true;
    startX = e.clientX;
    startLeft = container.offsetLeft;
    originalIndex = slots.indexOf(container);
    container.style.position = 'relative';
    container.style.zIndex = 1000;
    handle.setPointerCapture(e.pointerId);
  });

  handle.addEventListener('pointermove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    container.style.left = startLeft + dx + 'px';

    // Determine the potential slot
    const center = container.offsetLeft + SLOT_WIDTH/2;
    let newIndex = Math.floor(center / SLOT_WIDTH);
    if (newIndex < 0) newIndex = 0;
    if (newIndex >= slots.length) newIndex = slots.length - 1;

    // Remove container from array temporarily
    const tempSlots = slots.filter(c => c !== container);
    tempSlots.splice(newIndex, 0, container);
    
    // Move others to new positions
    tempSlots.forEach((c, i) => {
      if (c !== container) c.style.left = i * SLOT_WIDTH + 'px';
    });
  });

  handle.addEventListener('pointerup', (e) => {
    if (!isDragging) return;
    isDragging = false;
    container.style.zIndex = '';

    // Snap container to nearest slot
    const center = container.offsetLeft + SLOT_WIDTH/2;
    let newIndex = Math.floor(center / SLOT_WIDTH);
    if (newIndex < 0) newIndex = 0;
    if (newIndex >= slots.length) newIndex = slots.length - 1;

    // Remove container from slots and insert at newIndex
    slots = slots.filter(c => c !== container);
    slots.splice(newIndex, 0, container);

    updatePositions();
  });
}

function updatePositions() {
  slots.forEach((c,i) => {
    c.style.left = i * SLOT_WIDTH + 'px';
  });
}

addBtn.addEventListener('click', createUnit);

// Initial unit
createUnit();
</script>

</body>
</html>
